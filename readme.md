# Weather

This is a repo that implements a basic weather forecast server in both `golang` and `Rust` via the `openmeteo` API. Both servers offer the same basic functionality:

- `/` endpoint, which provides a form to query the forecast for a certain city
- `/weather` endpoint, which shows the forecast
- `/stats` endpoint, providing basic authentication to view recent transactions.

Recent transactions are stored in a local database, and require the existence of a `postgresSQL` server running on the local host. In this example, the `postgres` user, password, and database name are all `forecast`, and the code replies on the definition of the following environment variable:

```bash
export DATABASE_URL="postgres://forecast:forecast@localhost/forecast?sslmode=disable"
```



## Comparing http services between Golang and Rust

The goal of this little repo is to compare the development experience between simple servers in Golang and Rust, in the hopes I figure
out which I want to seriously consider for which projects in the near future. 

Not for production. 

These programs can be run with `go run` or `cargo run` from the respective directories.

## Golang

The `go` version of this server is much more "compact" in terms of file structure and import requirements, due to the fact that networking is more of a priority for gophers. To render the frontend, we use the `gin` framework, which is pretty complete and useful. This version of the server is compact, but any heavy computation needed for API requests, for example, will be limited by the other bugs/features of the language. Concurrency is handled by the built-in goroutines which, for a built-in tool, are notoriously extremely performant.

Being so compact, the `gin` engine also contains templating, for example, which is nice. Current development state is basic functionality (including `postgres` querying), but no `htmx` or styling.

## Rust

The `rust` version of the server is much more modular by design. This means more imports, but given how smoothly version changes, inter-crate compatability, etc, are integrated into the dev experience via `cargo`, it makes the long term robustness of the program easy to maintain. To create the frontend, we use the `axum` crate (rip `actix`) with the `askama` templating engine (which allows putting specific templates directly to specific structs which is sweeeeeet). These are all based on the components for networking provided by `tower`. To handle concurrency (async/await ops), we use the `tokio` crate.

The `gin` framework in `go` was much much more out of the box, providing all the tools for middleware, which was nice. A custom middleware had to be implemented to check authorization for a dummy `/stats` endpoint. 

While the codebase is much bulkier due to the bug/features of the language, as an academic exercise, it was much more useful to go through all this since I really got a feel of the language and its power more than in `go`. 

Current efforts focus on putting `tailwindcss` and `htmx` onto the frontend. Simple startup looks like
```bash
pnpm init
pnpm add -D tailwindcss prettier prettier-plugin-tailwindcss
```
and to be really sleek, we serve our static assets (namely the style sheet) in a compressed optimized `css` form that is autogenerated on changes to any `html` using `pnpm dlx tailwindcss -i styles/tailwind.css -o assets/main.css --watch`. Very cool. 

For right now, the `htmx` elements only serve a dummy api backend on the Rust server. 


## Conclusion

Hmm, can a gopher even eat a crustacean? Can a crustacean take down a gopher? Who knows.